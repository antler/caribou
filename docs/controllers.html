<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <script type="text/javascript" src="js/shCore.js"></script>
    <script type="text/javascript" src="js/shAutoloader.js"></script>
    <script type="text/javascript" src="js/shBrushClojure.js"></script>
    <script type="text/javascript" src="js/shBrushXml.js"></script>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/shCore.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/shThemeRDark.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/shClojureExtra.css" media="screen" />

    <title>Caribou Documentation</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Caribou Documentation</h1>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
<h1>Writing Controllers</h1><p>The whole point of the Caribou router is to funnel requests to the appropriate controller action with the right parameters.  Once a request comes through, an action is simply a function that is called with the request map as an argument, and evaluates to a valid response map.  In between of course, all kinds of magic can happen.</p><h2>Controllers are Namespaces which contain Actions</h2><p>To define a controller namespace, add a new file to your <code>src/{project}/controllers</code> directory with the name of the new controller.  So for this example it would be <code>src/taiga/controllers/example&#95;controller.clj</code> with the following contents:</p><pre class="brush: clj">
&#40;ns taiga.controllers.example-controller
  &#40;:require &#91;caribou.model :as model&#93;
            &#91;caribou.app.controller :as controller&#93;&#41;&#41;
</pre><p>Now you are ready to start writing some actions!</p><h2>Controller Actions are Functions</h2><p>To create a controller action is simply to write a function.  Caribou uses the <a href='https://github.com/ring-clojure/ring'>Ring protocol</a> as its basis for handling requests and returning responses.  In its simplest form, a controller looks like this:</p><pre class="brush: clj">
&#40;defn basic-action
  &#91;request&#93;
  {:status 200 :body &quot;This is a simple response&quot;}&#41;
</pre><p>Here we are ignoring anything in the request map and simply returning a response of 200 with the body "This is a simple response".  No fancy markup, no database transactions, nothing.  If you have simple needs, this may be all you require. </p><p>However, it is likely that you will want some information that lives in the request.  That is the subject of the next section.  <br /></p><h2>Contents of the Request Map</h2><p>Living in the request map are a variety of helpful keys that provide information about the nature of the incoming request.  This is the basic information any controller action can use to tailor a response to that specific request.  <br /></p><p>There are some basic keys that are available in any Ring request, currently the following:</p><pre class="brush: clj">
:uri 
:scheme 
:content-type 
:content-length 
:character-encoding 
:headers 
:request-method 
:body 
:ssl-client-cert 
:remote-addr 
:server-name 
:server-port 
</pre><p>Yet more are added by some Ring middleware that Caribou includes by default (which you are free to remove if you wish):</p><pre class="brush: clj">
:cookies 
:session 
:query-string 
:params 
:query-params 
:form-params 
:multipart-params 
</pre><p>There is a salad of params types that is an artifact of each being provided by a separate ring middleware handler.</p><p>Then there are the keys added by Caribou.  There are some basic ones which are provided to help with rendering:</p><ul><li><strong>:template</strong> A function which renders the template associated to this page    when called with a map of substitution values.</li><li><strong>:page</strong> A reference to the Page item that was matched during routing time.</li><li><strong>:is-xhr</strong> A boolean which signifies whether or not this request is xhr.</li><li><strong>:route-params</strong> A map of any parameters extracted from the url when the    route was matched.</li></ul><p>And then there are all the helpers.  A helper is simply a clojure function thatlives inside request map.  Caribou provides a handful of helpers by default, and you can add any more that seem helpful.</p><pre class="brush: clj">
;; value handling
:equals 

;; string handling
:truncate 
:linebreak 
:smartquote 

;; routing
:route-for 

;; image resizing
:resize 

;; date handling
:now
:ago 
:hh-mm 
:yyyy-mm-dd 
:yyyy-mm-dd-or-current 
:date-year 
:date-month 
:date-day
</pre><h2>Parameters from Routes are Available in Controllers</h2><p>In order to provide something beyond our first simple action, let's use some of the information from the incoming request.  In this example, we use a <code>:name</code> parameter to customize our response:</p><pre class="brush: clj">
&#40;defn parameter-action
  &#91;request&#93;
  &#40;let &#91;request-name &#40;-&gt; request :params :name&#41;&#93;
    {:status 200 :body &#40;str &quot;Hello &quot; request-name &quot;!&quot;&#41;}&#41;&#41;
</pre><p>This way, if this action is triggered by a page associated to the route "/hello/:name" for instance, the <code>:name</code> parameter will be set by whatever the value of the url is in that position.  So if someone makes a request to "/hello/lichen" the response will come back as</p><pre>
Hello lichen!
</pre><p>One basic pattern that is used over and over is to pull up some content from a model based on the value of a parameter and use that to form the response.  An example would be, given the route "/hello/:name" and a request to "/hello/antler", to pull up some content from a "User" model and respond with something that lives in that instance.  In this case we can say that the User model has a "Greeting" field that they prefer to be greeted by that is stored in the database:</p><pre class="brush: clj">
&#40;defn pick-action
  &#91;request&#93;
  &#40;let &#91;request-name &#40;-&gt; request :params :name&#41;
        user &#40;model/pick :user {:where {:name request-name}}&#41;
        greeting &#40;:greeting user&#41;&#93; ;; this user's :greeting is &quot;Obo&quot;
    {:status 200 :body &#40;str greeting &quot; &quot; request-name &quot;!&quot;&#41;}&#41;&#41;
</pre><p>The response for this would be:</p><pre>
Obo antler!
</pre><h2>Rendering Provides Data to Templates</h2><p>If you are using Caribou's default templating language, <a href='https://github.com/antler/antlers'>Antlers</a>, you can use the built in <code>caribou.app.controller/render</code> method to render your templates.  It will use the template defined in the page that routed the request to this action in the first place.  So instead of returning a map with <code>:status</code> and <code>:body</code> in it, you can just call render on some parameters instead.  A basic call looks like this:</p><pre class="brush: clj">
&#40;defn pick-action
  &#91;request&#93;
  &#40;let &#91;request-name &#40;-&gt; request :params :name&#41;
        user &#40;model/pick :user {:where {:name request-name}}&#41;&#93;
    &#40;controller/render &#40;assoc request :user user&#41;&#41;&#41;&#41;
</pre><p>The user map for this example contains:</p><pre class="brush: clj">
{:greeting &quot;Salutations&quot; :name &quot;Tundra Warrior&quot;}
</pre><p>Then in a template:</p><pre class="brush: html">
{{user.greeting}} {{user.name}}!
</pre><p>And out comes!:</p><pre>
Salutations Tundra Warrior!
</pre><p>Any key that is present in the map passed into <code>caribou.app.controller/render</code> can be used inside a template, including information about the request and the currently rendering page.  So if you need a page title and the current URL for instance,</p><pre class="brush: html">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{page.title}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;You are currently visiting {{uri}}!  Welcome!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre><p>More information about template rendering can be found in the <a href='#rendering-templates'>Rendering Templates</a> section.</p><h2>Defining a Siphon</h2><p>Often in controllers, the main work is to pull some content up out of the database based on the incoming parameters and hand that content to the template for rendering.  This doesn't apply to actions that update or create content or make requests of their own, but it does apply to any request that is simply fetching data that is then presented to the requester in some meaningful way.</p><p>Along these lines, Caribou has the concept of a Siphon.  A Siphon is a specification of what data to pull up and how to associate it based on the parameters of an incoming request.  It is itself data that lives in a map inside the Page:</p><pre class="brush: clj">
&#40;def page-with-siphon
  {:home 
   {:GET 
    {:controller &quot;home&quot; 
     :action &quot;index&quot; 
     :template &quot;index.html&quot;
     :siphons {:categories {:spec {:model :category
                                   :op    :gather
                                   :order {:created-at :desc}}}
               :user {:spec {:model :user
                             :op    :pick
                             :where {:id :$user-id}}}}}}}&#41;
</pre><p>Then you can access these values directly in the template without ever having to build a controller!  These values live inside the page under the <code>:content</code> key:</p><pre class="brush: html">
&lt;h1&gt;Welcome {{page.content.user.name}}!&lt;/h1&gt;

&lt;p&gt;Here are some Categories for you:&lt;/p&gt;
&lt;ul&gt;
{{#page.content.categories}}
&lt;li&gt;{{name}}&lt;/li&gt;
{{/page.content.categories}}
&lt;/ul&gt;
</pre><h2>Defining Pre-Actions</h2><p>Sometimes you find yourself writing the same code over and over for many different actions.  This can be to add some information into the request or to prevent the action from running entirely if certain conditions aren't met. Rather than include the same block of code or call to the same function at the beginning of every action like this, you can instead register a pre-action for these actions.</p><p>Say your desired pre-action is simply adding something to the request map:</p><pre class="brush: clj">
&#40;defn pre-tundraize
  &#91;action request&#93;
  &#40;action &#40;assoc request :tundra &quot;The serene open tundra&quot;&#41;&#41;&#41;
</pre><p>Notice pre-actions take two arguments, the action that would have originally be called and the incoming request.  This pre-action unconditionally calls the original action with a new <code>:tundra</code> key in the request map.  To register this as a pre-action for a given controller action, simply call <code>caribou.app.routing/register-pre-action</code> with the slug of the page governing this action:</p><pre class="brush: clj">
&#40;caribou.app.routing/register-pre-action :home pre-tundraize&#41;
</pre><p>Another use case is to prevent the action from running at all in certain cases, for example if the request is not authorized in some way:</p><pre class="brush: clj">
&#40;defn ensure-authorized
  &#91;action request&#93;
  &#40;if &#40;authorized? request&#41;
    &#40;action request&#41;
    {:status 401 :body &quot;Not authorized!&quot;}&#41;&#41;
</pre><p>Then you could register this pre-action in the same way as before: </p><pre class="brush: clj">
&#40;caribou.app.routing/register-pre-action :protected ensure-authorized&#41;
</pre><p>Now this action will only be run if the call to <code>&#40;authorized? request&#41;</code> returns true.</p>
      </section>
    </div>

    
  </body>
</html>

<script type="text/javascript">
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.autoloader(
    'clj clojure js/shBrushClojure.js',
    'xml html js/shBrushXml.js'
  );
  SyntaxHighlighter.all()
</script>
